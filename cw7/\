-- zad 7)
-- a)
sort :: [Int] -> [Int]
sort (x:xs) = sort_h [x] xs

sort_h :: [Int] -> [Int] -> [Int]
sort_h sorted [] = sorted
sort_h sorted (x:xs) = sort_h (insert x sorted) xs


insert :: Int -> [Int] -> [Int]
insert x [] = [x]
insert x (y:ys) | x < y = x:y:ys
                | otherwise = y : insert x ys
    
-- insert x [y] | x < y = [x]++[y] | otherwise = [y]++[x]

-- b)
bubble_sort [] = []
bubble_sort list = 
    let t1 = bubble_sort_h list
    in bubble_sort (init t1) ++ [last t1]

bubble_sort_h (x:y:xs) | x > y = y : bubble_sort(x:xs)
                     | otherwise = x : bubble_sort(y:xs)
bubble_sort_h (x) = (x)

-- zad 10)
data Tree a = Empty | Node a (Tree a) (Tree a) deriving (Show)

-- a)
shortest Empty = 0
shortest (Node a l r) = 1 + min (shortest l) (shortest r)

-- b)
longest Empty = 0
longest (Node a l r) = 1 + max (longest l) (longest r)

-- zad 14)
closer_or_further (a,b) (a1,b1) | l1 < l2 = LT | l2 > l1 = GT | otherwise = EQ
    where l1 = get_dist (a, b)
          l2 = get_dist (a1, b1)

sort_pairs :: [(Int, Int)] -> [(Int, Int)]
sort_pairs (x:xs) = sort_pairs_h [x] xs

sort_pairs_h :: [(Int, Int)] -> [(Int, Int)] -> [(Int, Int)]
sort_pairs_h sorted [] = sorted
sort_pairs_h sorted (x:xs) = sort_pairs_h (insert_pairs x sorted) xs

insert_pairs :: (Int, Int) -> [(Int, Int)] -> [(Int, Int)]
insert_pairs x [] = [x]
insert_pairs x (y:ys) | lx < ly = x:y:ys
		       | otherwise = y : insert_pairs x ys
    where lx = get_dist x
          ly = get_dist y

-- get_dist :: (Ord a, Floating a, Eq a) => (a, a) -> (a, a) -> a

get_dist :: (Floating a) => (Int, Int) -> Int 
get_dist (a,b) = sqrt ((a-0)**2 + (b-0)**2)

-- sort list = sort_h [head list] (tail list)

-- sort_h sorted [] = sorted
-- sort_h sorted not_sorted = sort_h (insert (head not_sorted) sorted) (tail not_sorted)


-- insert :: Int -> [Int] -> [Int]
-- insert x [] = [x]
-- insert x (y:ys) | x < y = x:y:ys
--                 | otherwise = y : insert x ys
    
-- insert x [y] | x < y = [x]++[y] | otherwise = [y]++[x]
